import scala.language.implicitConversions

import scala.concurrent.{ExecutionContext, Future}
import ExecutionContext.Implicits.global
import scala.reflect.macros.whitebox.Context
import scala.language.experimental.macros

/*
    Notes on implementing the join-syntax:

    We need to trick to compiler into accepting the types, then we
    can do whatever we want with macros. This means, the efficiency
    be achieved by other means, and the output generated by the compiler
    can be safely ignored. Maybe, at a later stage, it would be nice to
    have some tree that is easy to work with.

    We can convert futures implicitly into pattern objects. Syntactically,
    there seems to be a problem with using variable references at "extractor"
    positions. In the docs it says patterns in form of "Something(x)" mean
    that "Something" (in that case) has to be be a "Stable Identifier",
    which is a "Path" with "Id" at the end.

    We could force the user to create objects that extend Pattern, which type-checks,
    but is not particularly nice. This has been implemented now. An implicit conversion
    into a class with a conversion function makes the framework a bit nicer to use. The
    name of that method could be short, like "p" or "m", analogous to the "r" method to
    create regular expressions from strings, or longer and more descriptive, like
    "toPattern", or "asEvent".

    A further problem solved here is that Scala already has alternative "|" patterns.
    We resort to "||". To make the interface uniform, we should probably also use "&&"
    instead of "&". The problem is that the "&" and "&&" have different semantics with
    regarding to short-circuiting in normal boolean expression.

    The problem When "merging" multiple patterns is that the result should only be bound
    to a single variable. This cannot be expressed in scala using the same identifier,
    and also grouping, as in (f1 || f2)(x), will not work. We therefore resort to either
    providing two variables, like f1(x) || f2(y), which are set to the same value, or use
    "_" on one position, like f1(x) || f2(_).

    The following is a (possibly faulty) description of what happens in the scala compiler
    when it expands the partial function:

    join {
      case f1(x) && f2(y) => x + y
    }

    ==

    join {
      case &&.unapply((f1, f2)) => x + y // note: &&.unapply takes a pair of patterns
    }

    ==

    join {
      case &&.unapply((f1, f2)) match{
        case Some(p1, p2) => Pattern.unapply(p1) match {
          case Some(x) => Pattern.unapply(p2) match {
            case some(y) => x + y
          }
        }
      }
    }
*/

object Join {
  class Pattern[A](f: Future[A]) {
    def unapply(x: Any): Option[A] = ???
  }
  object Pattern {
    def apply[A](f: Future[A]) = new Pattern(f)
  }
  object && {
    def unapply(obj: Any): Option[(Pattern[_], Pattern[_])] = ???
  }
  object || {
    def unapply(obj: Any): Option[(Pattern[_], Pattern[_])] = ???
  }
  def join[A](pf: PartialFunction[Pattern[_], A]): A = ???

  def joinImpl = ???

  implicit class FutureJoinOps[A](f: Future[A]) {
    def p: Pattern[A] = Pattern(f)
  }
}

object test extends App {
  import Join._

  val f = Future { 42 }
  val g = Future { 43 }
  val h = Future { 44 }
  val k = Future { 45 }

  // Create pattern objects from futures using the "p" method
  val (f1, f2, f3, f4) = (f.p, g.p, h.p, k.p)

  // Express a join pattern
  val fut = join[Int] {
    case f1(x) && f2(y) && f3(z)  => x + y +z
    case f3(x) || f4(_) => x
  }
}
