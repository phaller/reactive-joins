# Scala Async-Join

// TODO: Write introduction etc.
// TODO: Handle line-breaks without \n

## Notes on join-syntax

We need to trick to compiler into accepting the types, then we
can do whatever we want with macros. This means, the efficiency
be achieved by other means, and the output generated by the compiler
can be safely ignored. Maybe, at a later stage, it would be nice to
have some tree that is easy to work with.

We can convert futures implicitly into pattern objects. Syntactically,
there seems to be a problem with using variable references at "extractor"
positions. In the docs it says patterns in form of "Something(x)" mean
that "Something" (in that case) has to be be a "Stable Identifier",
which is a "Path" with "Id" at the end.

We could force the user to create objects that extend Pattern, which type-checks,
but is not particularly nice. This has been implemented now. An implicit conversion
into a class with a conversion function makes the framework a bit nicer to use. The
name of that method could be short, like "p" or "m", analogous to the "r" method to
create regular expressions from strings, or longer and more descriptive, like
"toPattern", or "asEvent".

A further problem solved here is that Scala already has alternative "|" patterns which
unfortunately do not allow for variable pattern bindings.

We resort to "||". To make the interface uniform, we should probably also use "&&"
instead of "&". The problem is that the "&" and "&&" have different semantics with
regarding to short-circuiting in normal boolean expression.

The problem When "merging" multiple patterns is that the result should only be bound
to a single variable. This cannot be expressed in scala using the same identifier,
and also grouping, as in (f1 || f2)(x), will not work. We therefore resort to either
providing two variables, like f1(x) || f2(y), which are set to the same value, or use
"_" on one position, like f1(x) || f2(_).

The following is a (possibly faulty) description of what happens in the scala compiler
when it expands the partial function:

join {
  case f1(x) && f2(y) => x + y
}

==

join {
  case &&.unapply((f1, f2)) => x + y // note: &&.unapply takes a pair of patterns
}

==

join {
  case &&.unapply((f1, f2)) match{
    case Some(p1, p2) => Pattern.unapply(p1) match {
      case Some(x) => Pattern.unapply(p2) match {
        case some(y) => x + y
      }
    }
  }
}
